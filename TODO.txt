

REST API

The tracker database can be accesed via a http REST interface,
separate from the tracker interface.

GET /torrents/<InfoHash>/complete
{complete:12345}

GET /torrents/<InfoHash>/incomplete
{incomplete:53214}

GET /torrents/<InfoHash>/downloaded
{downloaded:459}

GET /torrents/<InfoHash>/
{complete:12345, incomplete:53214, downloaded:459}


Architecture

-	tracker_http - front service implementing the http tracker api as per
	http://wiki.theory.org/BitTorrentSpecification.
	
	It handles two kind of requests:
	
	/announce?info_hash=<tracked_torrent>&peer_id=<client id>&<...>
		A bittorrent client will hit this url to 
			- update the tracker view of client status in relation to tracked_torrent
			- ask for updated stats about tracked_torrent
			- ask for a list of peers
		
		The three operations are managed independently.
			
			-	a global event {announce, Peer} is raised. Installed
				event handlers could use this data to update a database.
			
			-	torrent_stats service is asked complete/incomplete count for
				tracked_torrent
				
			-	torrent_peers service is asked to produce
				a list of peers in binary format
								
	/scrape


# leave these lines alone

#ERL = erl -boot start_clean 
#ERL_TOP = 
#EBIN = ./ebin
#EBIN_TEST = ./ebin/test
#EBIN_MOCHIWEB = ./3rd/mochiweb/ebin
#ESRC = ./src/main
#ESRC_TEST = ./src/test

#BIN = ./bin
#RELEASE = ./release
#CONFIG = ./config
#INC = ./include 
#CC = erlc -I ${INC} -W0

#SRC			=	$(wildcard $(ESRC)/*.erl)
#SRC_TEST	=	$(wildcard $(ESRC_TEST)/*.erl)

#TARGET		=	$(addsuffix .beam, $(basename \
#				$(addprefix $(EBIN)/, $(notdir $(SRC)))))
				
#TARGET_TEST =	$(addsuffix .beam, $(basename \
#				$(addprefix $(EBIN_TEST)/, $(notdir $(SRC_TEST)))))
             
#all: dirs mochiweb ${TARGET} test
#	cp peasy.app $(EBIN)
	
#test:  ${TARGET_TEST}
#	@echo Running dialyzer...
#	@dialyzer --plt ebin/.dialyzer_plt -I ${INC} -r ./ebin -pa ./ebin 
	
	@echo Running test suite...
	@erl -pa $(EBIN) -pa $(EBIN_MOCHIWEB) -pa $(EBIN_TEST) -noshell -s all_tests test -s init stop

#ebin/.dialyzer_plt:
#	@echo Configuring dialyzer...
#	@dialyzer -r $ERL_TOP/lib/stdlib/ebin $ERL_TOP/lib/kernel/ebin $ERL_TOP/lib/mnesia/ebin \
#		--build_plt --output_plt ebin/.dialyzer_plt -I ${INC} -pa ./ebin -r ./ebin
	
#release: all test
#	mkdir -p $(RELEASE)
#	mkdir -p $(RELEASE)/log
#	cp -R $(EBIN) $(RELEASE)/
#	cp -R $(CONFIG) $(RELEASE)/
#	cp -R $(BIN) $(RELEASE)/
#	cp -R $(EBIN_MOCHIWEB) $(RELEASE)/ebin/mochiweb
	
# run development version
#run: ${TARGET}
#	erl -boot start_sasl  -pa $(EBIN) -pa $(EBIN_MOCHIWEB) -s peasy start
	
# run qa
#run_qa: ${TARGET}
#	erl -boot start_sasl -config  $(CONFIG)/cfg_qa -detached -pa $(EBIN) -pa $(EBIN_MOCHIWEB) -s peasy start

#docs:
#	erl -noshell -s edoc files ${MODS:%=%.erl} -s init stop

#dirs:
#	@echo "Creating dirs ..." 
#	@mkdir -p  ${EBIN} ${EBIN_TEST} 
	
#$(EBIN)/%.beam: $(ESRC)/%.erl 
#	@echo  "Compiling  $< ... "
#	@$(CC) +debug_info -o $(EBIN) $<

#$(EBIN_TEST)/%.beam: $(ESRC_TEST)/%.erl
#	@echo "Compiling test $< ... "
#	@$(CC) +debug_info -o $(EBIN_TEST) $<
	
# remove all the code

#mochiweb:
#	@echo Building mochiweb...
#	@cd 3rd/mochiweb && make

#clean:	
#	rm -rf $(EBIN)/*.beam $(EBIN_TEST)/*.beam erl_crash.dump
#	rm -rf $(RELEASE)
	

###### NEW Makefile, taken from Etorrent ######